---
title: "Unified eQTL & PC Optimization Report"
output: html_document
params:
  eqtl_results_filtered: NULL
  eqtl_results: NULL
  outdir: NULL
  gds_file: NULL
  single_cell_file: NULL
  single_cell_file_list: NULL
  counts_assay: NULL
  counts_slot: NULL
  celltype_column: NULL
  individual_column: NULL
  min_cells: NULL
  min_expression: NULL
  cis_distance: NULL
  filter_chr: NULL
  fdr_threshold: NULL
  cov_file: NULL
  covariates_to_include: NULL
  subset_column: NULL
  subset_values: NULL
  optimize_pcs: NULL
  fixed_pcs: NULL
  pc_coarse_step: NULL
  pc_fine_step: NULL
  pc_fine_window: NULL
  pc_elbow_tol: NULL
  pc_early_stop_tol: NULL
  pc_early_stop_patience: NULL
  workflow: NULL
  profile: NULL
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(dplyr)
library(ggplot2)
library(tidyr)
library(tidyverse)
library(gridExtra)
library(scales)
format_cis_distance <- function(distance) {
  if (distance >= 1e6) {
    return(paste0(distance / 1e6, "Mb"))
  } else if (distance >= 1e3) {
    return(paste0(distance / 1e3, "Kb"))
  } else {
    return(paste0(distance, "bp"))
  }
}
# Set theme for PC optimization plots
theme_set(theme_minimal() + theme(plot.title = element_text(hjust = 0.5, face = "bold")))
```

## eQTL Analysis Report

**Report Generated:** `r format(Sys.time(), "%d %B %Y, %H:%M:%S")`

This report was generated using the Nextflow eQTL Pipeline, a comprehensive tool for conducting expression quantitative trait loci (eQTL) analysis on single-cell RNA-seq data.

**GitHub Repository:** [https://github.com/johnsonlab-ic/sceQTL-flow](https://github.com/johnsonlab-ic/sceQTL-flow)

**Contact:** For questions or support regarding this pipeline, please contact Alexander Haglund (GitHub: [HaglundA](https://github.com/HaglundA))

---

### Pipeline Settings

The following settings were used in the pipeline:

```{r params-table, echo=FALSE}
params_tbl <- tibble::tibble(
  Parameter = c(
    "Output directory",
    "Workflow",
    "Profile",
    "GDS file",
    "Single-cell file",
    "Single-cell file list",
    "Counts assay",
    "Counts slot",
    "Cell-type column",
    "Individual column",
    "Min cells",
    "Min expression",
    "Cis distance",
    "Chromosomes",
    "FDR threshold",
    "Covariate file",
    "Covariates to include",
    "Subset column",
    "Subset values",
    "Optimize PCs",
    "Fixed PCs",
    "PC coarse step",
    "PC fine step",
    "PC fine window",
    "PC elbow tolerance",
    "PC early-stop tolerance",
    "PC early-stop patience"
  ),
  Value = c(
    params$outdir,
    params$workflow,
    params$profile,
    params$gds_file,
    params$single_cell_file,
    params$single_cell_file_list,
    params$counts_assay,
    params$counts_slot,
    params$celltype_column,
    params$individual_column,
    params$min_cells,
    params$min_expression,
    format_cis_distance(params$cis_distance),
    params$filter_chr,
    params$fdr_threshold,
    params$cov_file,
    params$covariates_to_include,
    params$subset_column,
    params$subset_values,
    params$optimize_pcs,
    params$fixed_pcs,
    params$pc_coarse_step,
    params$pc_fine_step,
    params$pc_fine_window,
    params$pc_elbow_tol,
    params$pc_early_stop_tol,
    params$pc_early_stop_patience
  )
)

knitr::kable(params_tbl, col.names = c("Parameter", "Value"))
```

```{r eqtl-load, echo=FALSE}
# Load the filtered eQTL results
if (!is.null(params$eqtl_results_filtered) && file.exists(params$eqtl_results_filtered)) {
  eqtl_results_filtered <- readRDS(params$eqtl_results_filtered)
} else {
  eqtl_results_filtered <- NULL
}

# Load the eQTL results
if (!is.null(params$eqtl_results) && file.exists(params$eqtl_results)) {
  eqtl_results <- readRDS(params$eqtl_results)
} else {
  eqtl_results <- NULL
}
# Number and names of cell-types tested
cell_types <- if (!is.null(eqtl_results_filtered)) names(eqtl_results_filtered) else character(0)
num_celltypes <- length(cell_types)

if (!is.null(eqtl_results) && num_celltypes > 0) {
  genes_list <- lapply(eqtl_results, function(df) unique(df$gene))
  all_genes <- unlist(genes_list)
  avg_genes_tested <- length(all_genes) / num_celltypes

  snps_list <- lapply(eqtl_results, function(df) unique(df$SNP))
  all_snps <- unique(unlist(snps_list))
  num_snps_tested <- length(all_snps)
} else {
  avg_genes_tested <- NA
  num_snps_tested <- NA
}
```

### Input Overview

- **Number of cell-types tested:** `r num_celltypes`
- **Names of cell-types tested:** `r paste(cell_types, collapse=", ")`
- **Average number of genes tested per cell-type:** `r avg_genes_tested`
- **Number of SNPs tested:** `r num_snps_tested`

---

## Total and Unique eGenes (5% FDR)

```{r plot-total-unique-egenes, echo=FALSE}
if (!is.null(eqtl_results_filtered)) {
  total_genes <- function(cell_list) {
    sapply(cell_list, function(df) length(unique(df$gene)))
  }

  total_unique_genes <- function(cell_list) {
    sapply(cell_list, function(df) {
      current_genes <- unique(df$gene)
      other_genes <- unique(unlist(lapply(cell_list, function(other_df) {
        if (identical(df, other_df)) return(NULL)
        other_df$gene
      })))
      length(setdiff(current_genes, other_genes))
    })
  }

  mateqtlouts <- eqtl_results_filtered

  mateqtlouts_filt <- lapply(mateqtlouts, function(x) {
    x <- x %>% mutate(se = beta / t.stat, fstat = t.stat^2)
    x %>%
      group_by(gene) %>%
      arrange(p.value) %>%
      slice_head(n = 1) %>%
      ungroup() %>%
      arrange(FDR)
  })

  tot_eGenes <- total_genes(mateqtlouts_filt)
  tot_unique_eGenes <- total_unique_genes(mateqtlouts_filt)
  df <- data.frame(tot_eGenes, tot_unique_eGenes)
  df$celltype <- rownames(df)
  df$celltype <- gsub("_", " ", df$celltype)

  color_pal <- scales::hue_pal()(length(unique(df$celltype)))
  colorvec <- setNames(color_pal, unique(df$celltype))
  df$colorvec <- colorvec

  df <- df[order(df$tot_eGenes, decreasing = TRUE), ]
  df_long <- df %>%
    pivot_longer(cols = c(tot_eGenes, tot_unique_eGenes), names_to = "gene_type", values_to = "count")
  df_long$gene_type <- factor(df_long$gene_type, levels = c("tot_unique_eGenes", "tot_eGenes"))
  df_long$celltype_col <- rep(c(2, 1), times = nrow(df_long) / 2)
  df_long$celltype_col <- factor(df_long$celltype_col)
  df_long$celltype <- factor(df_long$celltype, levels = rev(df$celltype))
  df_long$celltype_col <- paste0(df_long$celltype, df_long$celltype_col)

  make_lighter <- function(hex, fraction = 0.4) {
    rgb <- col2rgb(hex)
    new_rgb <- rgb + fraction * (255 - rgb)
    rgb(new_rgb[1], new_rgb[2], new_rgb[3], maxColorValue = 255)
  }

  colorvec <- df_long$colorvec
  new_colors <- c(rbind(colorvec[c(TRUE, FALSE)], sapply(colorvec[c(TRUE, FALSE)], make_lighter)))
  names(new_colors) <- df_long$celltype_col
  max_val <- max(df_long$count) + 0.12 * max(df_long$count)

  g <- ggplot(df_long, aes(x = celltype, y = count, fill = celltype_col)) +
    geom_bar(stat = "identity", position = position_dodge(), width = 0.8, colour = "black") +
    geom_text(aes(label = count), position = position_dodge(width = 0.9), hjust = -0.2, size = 6 / .pt) +
    scale_fill_manual(values = new_colors) +
    labs(y = "Total vs unique eGenes (5% FDR)") +
    coord_flip(ylim = c(NA, max_val)) +
    theme_classic() +
    theme(
      axis.text.x = element_text(size = 6.5, colour = "black"),
      axis.title.y = element_blank(),
      axis.text.y = element_text(size = 6.5, colour = "black"),
      axis.title.x = element_text(size = 7, face = "bold"),
      legend.position = "none"
    )

  print(g)
} else {
  cat("Filtered eQTL results not available for eGene plot.\n")
}
```

# PC Optimization Results

```{r pcopt-setup, echo=FALSE}
outdir <- params$outdir
opt_dir <- file.path(outdir, "optimization")
```

## PC Optimization Strategy

This section details the two-stage PC optimization process used in the eQTL pipeline.

### Overview

The pipeline employs a **coarse-to-fine grid search** with **early stopping** and **elbow tolerance** to select the optimal number of principal components (PCs) for each cell type:

1. **Coarse Stage**: Test PCs in steps of 10 (2, 12, 22, ...) up to 50% of sample size
2. **Early Stopping**: Halt coarse evaluation when 2 consecutive steps show <1% improvement
3. **Fine Stage**: Refine search around the best coarse PC (±10 in steps of 2)
4. **Elbow Selection**: Pick the smallest PC count within 2% of maximum associations

---

## Coarse Grid Optimization

```{r coarse-load}
coarse_files <- list.files(opt_dir, pattern = "_coarse_summary.csv$", full.names = TRUE)
if (length(coarse_files) == 0) {
  cat("No coarse optimization results found.\n")
  coarse_data <- NULL
} else {
  coarse_data <- map_df(coarse_files, ~{
    celltype <- gsub("_coarse_summary.csv", "", basename(.x))
    fread(.x) %>% mutate(celltype = celltype)
  }, .id = "file") %>%
    select(-file) %>%
    as_tibble()
}
```

### Coarse Results by Cell Type

```{r coarse-table}
if (!is.null(coarse_data)) {
  coarse_data %>%
    select(celltype, n_pcs, n_assoc, gain_pct, below_threshold, is_ceiling, is_best) %>%
    mutate(
      gain_pct = round(gain_pct, 2),
      n_pcs_label = paste0(n_pcs, if_else(is_ceiling, " ⬅️ CEILING", ""), 
                           if_else(is_best, " ⭐ BEST", ""))
    ) %>%
    select(-is_ceiling, -is_best) %>%
    knitr::kable(
      caption = "Coarse Grid Results: All PC counts tested with gains and early-stop indicators",
      col.names = c("Cell Type", "n_PCs", "n_Associations", "Gain (%)", "Below 1% Tol?", "n_PCs Label")
    )
} else {
  cat("No coarse data available.\n")
}
```

### Coarse Gains Visualization

```{r coarse-plot, fig.cap="Coarse grid gains: Shows % improvement in associations as PCs increase. Red line = early-stop threshold (1%). Red dashed line = ceiling PC (where 2 consecutive gains <1%)."}
if (!is.null(coarse_data)) {
  p_list <- coarse_data %>%
    group_by(celltype) %>%
    group_map(~{
      .x %>%
        arrange(n_pcs) %>%
        ggplot(aes(x = n_pcs, y = gain_pct, color = below_threshold)) +
        geom_line(color = "gray60", size = 0.8) +
        geom_point(size = 3, aes(color = below_threshold)) +
        geom_hline(yintercept = 1, linetype = "dashed", color = "red", size = 1, alpha = 0.5) +
        geom_vline(data = filter(.x, is_ceiling), aes(xintercept = n_pcs), 
                   linetype = "dashed", color = "darkred", size = 1, alpha = 0.5) +
        scale_color_manual(values = c("FALSE" = "steelblue", "TRUE" = "orange"),
                          name = "Below 1%?") +
        labs(
          title = paste0("Cell Type: ", unique(.x$celltype)),
          x = "Number of PCs",
          y = "Gain (%)",
          subtitle = "Red horizontal = threshold (1%), Red vertical = ceiling (early-stop)"
        ) +
        theme(legend.position = "bottom")
    })
  if (length(p_list) > 0) {
    do.call(gridExtra::grid.arrange, c(p_list, ncol = 2))
  }
} else {
  cat("No coarse data for visualization.\n")
}
```

---

## Fine Grid Optimization

```{r fine-load}
fine_files <- list.files(opt_dir, pattern = "_fine_summary.csv$", full.names = TRUE)
if (length(fine_files) == 0) {
  cat("No fine optimization results found.\n")
  fine_data <- NULL
} else {
  fine_data <- map_df(fine_files, ~{
    celltype <- gsub("_fine_summary.csv", "", basename(.x))
    fread(.x) %>% mutate(celltype = celltype)
  }, .id = "file") %>%
    select(-file) %>%
    as_tibble()
}
```

### Fine Results by Cell Type

```{r fine-table}
if (!is.null(fine_data)) {
  fine_data %>%
    select(celltype, n_pcs, n_assoc, threshold, within_elbow, is_selected) %>%
    mutate(
      threshold = round(threshold, 0),
      n_pcs_label = if_else(is_selected, paste0(n_pcs, " ⭐ SELECTED"), as.character(n_pcs))
    ) %>%
    select(-is_selected) %>%
    knitr::kable(
      caption = "Fine Grid Results: PC counts within the refined window with elbow tolerance applied",
      col.names = c("Cell Type", "n_PCs", "n_Associations", "Elbow Threshold", "Within Elbow?", "Label")
    )
} else {
  cat("No fine data available.\n")
}
```

### Fine Grid Visualization with Elbow Rule

```{r fine-plot, fig.cap="Fine grid results: Blue dots = tested PCs, green dot = selected PC (smallest within 2% of maximum), light blue band = elbow tolerance region."}
if (!is.null(fine_data)) {
  p_list <- fine_data %>%
    group_by(celltype) %>%
    group_map(~{
      max_assoc <- max(.x$n_assoc, na.rm = TRUE)
      threshold <- unique(.x$threshold)[1]
      selected_pc <- .x %>% filter(is_selected) %>% pull(n_pcs) %>% first()
      .x %>%
        arrange(n_pcs) %>%
        ggplot(aes(x = n_pcs, y = n_assoc)) +
        geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = threshold, ymax = max_assoc),
                 fill = "lightblue", alpha = 0.3, inherit.aes = FALSE) +
        geom_line(color = "gray60", size = 0.8) +
        geom_point(size = 3, color = "steelblue") +
        geom_point(data = filter(.x, is_selected), size = 5, color = "darkgreen", shape = 17) +
        geom_hline(yintercept = max_assoc, linetype = "dashed", color = "red", alpha = 0.5) +
        labs(
          title = paste0("Cell Type: ", unique(.x$celltype)),
          x = "Number of PCs",
          y = "Number of Significant Associations (FDR<0.05)",
          subtitle = paste0("Selected n_PCs = ", selected_pc, " (smallest within 2% of max)")
        )
    })
  if (length(p_list) > 0) {
    do.call(gridExtra::grid.arrange, c(p_list, ncol = 2))
  }
} else {
  cat("No fine data for visualization.\n")
}
```

---

## Summary: Selected PC Counts

```{r summary-table}
if (!is.null(fine_data)) {
  selected_pcs <- fine_data %>%
    filter(is_selected) %>%
    select(celltype, n_pcs, n_assoc) %>%
    rename(`Cell Type` = celltype, `Selected n_PCs` = n_pcs, `n_Associations at Selection` = n_assoc) %>%
    arrange(`Cell Type`)
  knitr::kable(
    selected_pcs,
    caption = "Final Selected PC Counts for Each Cell Type"
  )
} else {
  cat("No selection data available.\n")
}
```

---

## Parameters Used

```{r params-table}
params_summary <- tibble(
  Parameter = c("Coarse Step", "Fine Step", "Fine Window", "Early Stop Tolerance", "Early Stop Patience", "Elbow Tolerance"),
  Value = c("10", "2", "±10", "1%", "2 consecutive steps", "2%"),
  Description = c(
    "PC increment for coarse grid",
    "PC increment for fine grid",
    "Range around best coarse PC",
    "Threshold for low gain detection",
    "Consecutive low-gain steps to trigger stop",
    "Allow up to 2% below maximum associations"
  )
)
knitr::kable(params_summary, caption = "PC Optimization Parameters")
```

---

## Interpretation Guide

### Coarse Stage
- **Early Stopping**: If 2 consecutive steps show <1% improvement in associations, coarse evaluation halts
- **Ceiling**: The last PC value before early stopping triggers
- **Best Coarse PC**: The PC with maximum associations **up to the ceiling**

### Fine Stage
- **Elbow Tolerance**: Region within 2% of the maximum associations
- **Selected PC**: The smallest PC count in the elbow region (balances accuracy with parsimony)
- **Interpretation**: This selection avoids overfitting (too many PCs) while capturing nearly-optimal eQTL power

### Example
If coarse shows gains of 10%, 4%, 0.8%, 0.2%:
- Early stop triggers at PC showing 0.2% (2 consecutive <1%)
- Ceiling = PC at 0.2%
- Best coarse = PC with highest associations before ceiling
- Fine grid = ±10 around best coarse
- Final = smallest PC in fine grid within 2% of max

---

# eQTL Results Summary

... (rest of the original final_report.Rmd content, e.g., eGene plots, tables, etc.) ...
